<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Posture Check (MediaPipe Pose Landmarker)</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .wrap { position: relative; display: inline-block; }
    .media { width: 720px; max-width: 95vw; border-radius: 12px; background: #111; display: block; }
    canvas { position:absolute; left:0; top:0; }
    .panel { margin-top: 12px; padding: 12px; border: 1px solid #ddd; border-radius: 12px; max-width: 720px; }
    .badge { display:inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid #ddd; margin-left: 8px; }
    .warn { border-color: #ff9f0a; }
    .danger { border-color: #ff3b30; }
    small { color:#555; }
    input[type="number"]{ width: 84px; }
  </style>

  <!-- MediaPipe Tasks Vision CDN (vision_bundle.mjs) -->
  <script type="module">
    import {
      PoseLandmarker,
      FilesetResolver,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.mjs";

    // --- DOM ---
    const video = document.getElementById("video");
    const imageEl = document.getElementById("image");
    const imageInput = document.getElementById("imageInput");
    const imageControls = document.getElementById("imageControls");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const btn = document.getElementById("toggle");
    const camSel = document.getElementById("camera");
    const statusEl = document.getElementById("status");
    const angleEl = document.getElementById("angle");
    const levelEl = document.getElementById("level");

    const thWarnEl = document.getElementById("thWarn");
    const thDangerEl = document.getElementById("thDanger");
    const smoothEl = document.getElementById("smooth");

    const IMAGE_MODE_VALUE = "__image__";
    const DEFAULT_IMAGE_SRC = "./ad273b7c-9d8a-41e8-88ec-9f701afa84d1.png";

    // --- State ---
    let vision;
    let landmarkerVideo;
    let landmarkerImage;
    let drawingUtils;
    let stream = null;
    let running = false;
    let lastVideoTime = -1;
    let emaAngle = null; // smoothing

    // Pose model: Lite / Full / Heavy (using Lite)
    const MODEL_URL =
      "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task";

    function deg(rad){ return rad * 180 / Math.PI; }

    function isImageMode(){
      return camSel.value === IMAGE_MODE_VALUE;
    }

    function updateModeUI(){
      const imgMode = isImageMode();
      imageControls.style.display = imgMode ? "flex" : "none";
      video.style.display = imgMode ? "none" : "block";
      imageEl.style.display = imgMode ? "block" : "none";
    }

    // Trunk flexion angle (2D)
    // hipCenter -> shoulderCenter vector angle from vertical axis
    function trunkFlexionAngle2D(landmarks){
      // MediaPipe Pose indices:
      // 11 L shoulder, 12 R shoulder, 23 L hip, 24 R hip
      const ls = landmarks[11], rs = landmarks[12], lh = landmarks[23], rh = landmarks[24];
      if(!ls || !rs || !lh || !rh) return null;

      // If visibility is low, return null
      const visMin = 0.5;
      if((ls.visibility ?? 1) < visMin || (rs.visibility ?? 1) < visMin ||
         (lh.visibility ?? 1) < visMin || (rh.visibility ?? 1) < visMin) return null;

      const shoulder = { x:(ls.x+rs.x)/2, y:(ls.y+rs.y)/2 };
      const hip      = { x:(lh.x+rh.x)/2, y:(lh.y+rh.y)/2 };

      const vx = shoulder.x - hip.x;
      const vy = shoulder.y - hip.y;

      // Image coordinates: +y is downward.
      // angle = atan2(x, -y). 0° = upright, 90° = horizontal.
      const angle = Math.abs(deg(Math.atan2(vx, -vy)));
      return angle;
    }

    function postureLevel(angleDeg, warnDeg, dangerDeg){
      if(angleDeg == null) return { label:"No data", cls:"" };
      if(angleDeg >= dangerDeg) return { label:"Danger", cls:"danger" };
      if(angleDeg >= warnDeg) return { label:"Warn", cls:"warn" };
      return { label:"OK", cls:"" };
    }

    async function getVision(){
      if(!vision){
        vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );
      }
      return vision;
    }

    async function getLandmarker(mode){
      const v = await getVision();
      if(mode === "VIDEO"){
        if(!landmarkerVideo){
          landmarkerVideo = await PoseLandmarker.createFromOptions(v, {
            baseOptions: { modelAssetPath: MODEL_URL },
            runningMode: "VIDEO",
            numPoses: 1,
            minPoseDetectionConfidence: 0.5,
            minPosePresenceConfidence: 0.5,
            minTrackingConfidence: 0.5
          });
        }
        return landmarkerVideo;
      }

      if(!landmarkerImage){
        landmarkerImage = await PoseLandmarker.createFromOptions(v, {
          baseOptions: { modelAssetPath: MODEL_URL },
          runningMode: "IMAGE",
          numPoses: 1,
          minPoseDetectionConfidence: 0.5,
          minPosePresenceConfidence: 0.5,
          minTrackingConfidence: 0.5
        });
      }
      return landmarkerImage;
    }

    function ensureDrawingUtils(){
      if(!drawingUtils){
        drawingUtils = new DrawingUtils(ctx);
      }
    }

    async function listCameras(){
      // enumerateDevices shows labels after getUserMedia permission
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === "videoinput");
      const prev = camSel.value;

      camSel.innerHTML = "";
      const imgOpt = document.createElement("option");
      imgOpt.value = IMAGE_MODE_VALUE;
      imgOpt.textContent = "Image file";
      camSel.appendChild(imgOpt);

      cams.forEach((c, i) => {
        const opt = document.createElement("option");
        opt.value = c.deviceId;
        opt.textContent = c.label || `Camera ${i+1}`;
        camSel.appendChild(opt);
      });

      if(prev && [...camSel.options].some(o => o.value === prev)){
        camSel.value = prev;
      } else if(cams.length > 0){
        camSel.value = cams[0].deviceId;
      } else {
        camSel.value = IMAGE_MODE_VALUE;
      }

      updateModeUI();
      return cams.length;
    }

    async function startCamera(){
      if(stream) stopCamera();
      const deviceId = camSel.value || undefined;

      stream = await navigator.mediaDevices.getUserMedia({
        video: deviceId ? { deviceId: { exact: deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } }
                        : { width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();

      syncCanvasToVideo();
      await listCameras();
    }

    function stopCamera(){
      if(stream){
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      video.srcObject = null;
    }

    function syncCanvasToVideo(){
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.style.width = video.clientWidth + "px";
      canvas.style.height = video.clientHeight + "px";
    }

    function syncCanvasToImage(){
      canvas.width = imageEl.naturalWidth;
      canvas.height = imageEl.naturalHeight;
      canvas.style.width = imageEl.clientWidth + "px";
      canvas.style.height = imageEl.clientHeight + "px";
    }

    async function loadImage(url, revokeAfterLoad = false){
      return new Promise((resolve, reject) => {
        const cleanup = () => {
          imageEl.onload = null;
          imageEl.onerror = null;
        };
        imageEl.onload = () => {
          cleanup();
          if(revokeAfterLoad) URL.revokeObjectURL(url);
          resolve();
        };
        imageEl.onerror = (e) => {
          cleanup();
          if(revokeAfterLoad) URL.revokeObjectURL(url);
          reject(e);
        };
        imageEl.src = url;
      });
    }

    async function ensureImageReady(){
      if(!imageEl.src){
        await loadImage(DEFAULT_IMAGE_SRC);
        return;
      }
      if(imageEl.complete && imageEl.naturalWidth > 0) return;
      await new Promise((resolve, reject) => {
        imageEl.onload = () => resolve();
        imageEl.onerror = (e) => reject(e);
      });
    }

    function drawPose(landmarks){
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if(landmarks){
        drawingUtils.drawConnectors(landmarks, PoseLandmarker.POSE_CONNECTIONS);
        drawingUtils.drawLandmarks(landmarks, { radius: 3 });

        const raw = trunkFlexionAngle2D(landmarks);
        const alpha = Math.min(Math.max(Number(smoothEl.value) || 0.25, 0), 1);
        if(raw != null){
          emaAngle = (emaAngle == null) ? raw : (alpha * raw + (1 - alpha) * emaAngle);
        }
        const shown = (emaAngle == null) ? null : emaAngle;

        if(shown == null){
          angleEl.textContent = "-";
        }else{
          angleEl.textContent = shown.toFixed(1);
        }

        const warnDeg = Number(thWarnEl.value) || 25;
        const dangerDeg = Number(thDangerEl.value) || 35;
        const level = postureLevel(shown, warnDeg, dangerDeg);

        levelEl.textContent = level.label;
        levelEl.className = "badge " + (level.cls || "");
      } else {
        angleEl.textContent = "-";
        levelEl.textContent = "No person";
        levelEl.className = "badge";
      }
    }

    function renderVideo(){
      if(!running || isImageMode()) return;
      if(video.currentTime !== lastVideoTime){
        const res = landmarkerVideo.detectForVideo(video, performance.now());
        lastVideoTime = video.currentTime;
        drawPose(res?.landmarks?.[0]);
      }
      requestAnimationFrame(renderVideo);
    }

    async function renderImage(){
      if(!running || !isImageMode()) return;
      await ensureImageReady();
      syncCanvasToImage();
      const res = landmarkerImage.detect(imageEl);
      drawPose(res?.landmarks?.[0]);
    }

    async function startVideoMode(){
      statusEl.textContent = "Loading model...";
      await getLandmarker("VIDEO");
      ensureDrawingUtils();
      updateModeUI();
      await startCamera();
      running = true;
      btn.textContent = "Stop";
      statusEl.textContent = "Running";
      emaAngle = null;
      lastVideoTime = -1;
      renderVideo();
    }

    async function startImageMode(){
      statusEl.textContent = "Loading model...";
      await getLandmarker("IMAGE");
      ensureDrawingUtils();
      updateModeUI();
      stopCamera();
      running = true;
      btn.textContent = "Stop";
      statusEl.textContent = "Image";
      emaAngle = null;
      lastVideoTime = -1;
      await renderImage();
    }

    function stop(){
      running = false;
      btn.textContent = "Start";
      statusEl.textContent = "Stopped";
      emaAngle = null;
      lastVideoTime = -1;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      stopCamera();
    }

    // UI events
    btn.addEventListener("click", async () => {
      try{
        if(!running){
          if(isImageMode()) await startImageMode();
          else await startVideoMode();
        }else{
          stop();
        }
      }catch(e){
        console.error(e);
        statusEl.textContent = "Error: " + (e?.message || e);
      }
    });

    camSel.addEventListener("change", async () => {
      try{
        updateModeUI();
        if(isImageMode()){
          await startImageMode();
        }else if(running){
          await startVideoMode();
        }
      }catch(e){
        console.error(e);
        statusEl.textContent = "Error: " + (e?.message || e);
      }
    });

    imageInput.addEventListener("change", async () => {
      const file = imageInput.files && imageInput.files[0];
      if(!file) return;
      try{
        const url = URL.createObjectURL(file);
        await loadImage(url, true);
        camSel.value = IMAGE_MODE_VALUE;
        updateModeUI();
        await startImageMode();
      }catch(e){
        console.error(e);
        statusEl.textContent = "Error: " + (e?.message || e);
      }
    });

    // Preload camera list (labels may be empty until permission)
    listCameras().catch(()=>{});
  </script>
</head>

<body>
  <h2>姿勢チェック（MediaPipe Pose Landmarker）</h2>

  <div class="row">
    <button id="toggle">Start</button>
    <label>Camera:
      <select id="camera"></select>
    </label>
    <span>State: <b id="status">Idle</b></span>
  </div>

  <div class="wrap" style="margin-top:12px;">
    <video id="video" class="media" playsinline muted></video>
    <img id="image" class="media" alt="Selected image" style="display:none" />
    <canvas id="canvas"></canvas>
  </div>

  <div class="row" id="imageControls" style="margin-top:8px; display:none;">
    <label>Image file:
      <input id="imageInput" type="file" accept="image/*" />
    </label>
    <small>Default: ad273b7c-9d8a-41e8-88ec-9f701afa84d1.png</small>
  </div>

  <div class="panel">
    <div class="row">
      <div>体幹前屈角（推定）: <b><span id="angle">-</span>&deg;</b></div>
      <div class="badge" id="level">-</div>
    </div>

    <div class="row" style="margin-top:10px;">
      <label>Warnしきい値(&deg;):
        <input id="thWarn" type="number" value="25" min="0" max="90" step="1" />
      </label>
      <label>Dangerしきい値(&deg;):
        <input id="thDanger" type="number" value="35" min="0" max="90" step="1" />
      </label>
      <label>平滑化係数(0-1):
        <input id="smooth" type="number" value="0.25" min="0" max="1" step="0.05" />
      </label>
    </div>

    <p style="margin-top:10px;">
      <small>
        目安: 体幹前屈角はカメラ位置や被写体の向きで変わります。
        カメラは胸〜腰が正面に入る位置に置くと安定します。
        これは簡易的なデモであり、医療・診断用途ではありません。
      </small>
    </p>
  </div>
</body>
</html>
